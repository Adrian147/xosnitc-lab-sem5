alias physicalSP S0;
alias currentPID S1;
alias currentPCB S2;
alias cause S3;
alias vpagenum S4;
alias ipaddr S5; 
alias replacePage S6;
alias nextPID S7;
alias nextPTBR S8;
alias i S9;
alias j S10;
alias flag S11;
alias reqblock S12;

//Extracting the values in the Exception Flag Registers
cause = EFR % 10;
vpagenum = (EFR / 10) % 100; 
ipaddr = (EFR / 1000);

if (cause == 0) then
    print("Page 404");
    print(ipaddr);
    print(vpagenum);
    //Physical SP value
    physicalSP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512); 

    // Calculating PID
    currentPID = (PTBR - 1024) / 8;

    // Calculating PCB entry for currentPID
    currentPCB = READY_LIST + 32 * currentPID;
    
    // Checking if vpagenum points to a Index
    if([PTBR + vpagenum * 2] == -1) then
        print("Invalid index");
        //Going to the Exit() Syscall.
        SP = SP + 1;
        physicalSP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512);
        [physicalSP - 1] = 10;
        inline "JMP 11776";	
    endif;
    
    //Looking for a free page for allotment
    i = 25;

    while (i < 64) do
        //Invalidating Index to FAT Table
        if ([MEM_LIST + i] == 0) then
            break;
        endif;
        i = i + 1;
    endwhile;
    
    flag = -1;
    //Setting the page index where required page to be stored
    if (i != 64) then
        [MEM_LIST + i] = 1;
        replacePage = i;
    else
        //Using Second Change Replacement
        nextPID = currentPID + 1;
        while(nextPID != currentPID) do
            nextPTBR = PAGE_TABLE + 8 * nextPID;
            
            i = 0;
            // Running through the Page Table for Victim Page
            while(i < 3) do
                j = nextPTBR + i * 2;
                //Checking if page used
                if ([j] != -1)then
                    //Checking if second chanced and not shared 
                    if ([j + 1] == "01" && [MEM_LIST + [j]] == 1) then
                        flag = i;
                        break;
                    endif;
                    
                    //Setting the Second Chance state marker
                    if ([j + 1] == "11") then
                        [j + 1] = "01";
                    endif;
                endif;
                
                i = i + 1;
            endwhile;
            
            //If a victim page is found
            if(flag != -1) then
                break;
            endif;
            
            nextPID = (nextPID + 1) % 32;
        endwhile;
        
        if (nextPID == currentPID) then
            breakpoint;
            print("No pages"); // Ever the case possible
            //or run second chance again.
            
            //Going to the Exit() Syscall.
            SP = SP + 1;
            physicalSP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512);
            [physicalSP - 1] = 10;
            inline "JMP 11776";	
        endif;
        
        //Sending Victim Page to the Swap Area
        i = 448;
        while (i < 512) do
            if ([DISK_LIST + i] == 0) then
                break;
            endif;
        
            i = i + 1;
        endwhile;
        
        //If no swap block is found
        if (i == 512) then
            print("No pages in SWAP");
            
            //Going to the Exit() Syscall.
            SP = SP + 1;
            physicalSP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512);
            [physicalSP - 1] = 10;
            inline "JMP 11776";	
        endif;
        
        //Storing victim page number
        replacePage = [nextPTBR + flag * 2];
        
        //Swapping out the block
        store(replacePage, i);
        [DISK_LIST + i] = 1;
        
        //Setting entry to SWAP index
        [nextPTBR + flag * 2] = i;
        
        //Setting the page to invalid
        [nextPTBR + flag * 2  + 1] = "00";
    endif;
    
    //storing the required block to load into victim
    reqblock = [PTBR + vpagenum * 2];
    
    //Loading the Required page
    load (replacePage, reqblock);
    
    if (reqblock > 448) then
        //Stating that swap block will not be used for this page
        [DISK_LIST + reqblock] = [DISK_LIST + reqblock] - 1;
    endif;
    
    //Setting the Page entry values
    [PTBR + vpagenum * 2] = replacePage;
    [PTBR + vpagenum * 2 + 1] = "11";
    
    ireturn;
else
    print("Exception!!");
    print("At line");
    print(ipaddr);
    print("-----");
    print(cause);
    print("-----");
    
    if (cause == 1) then
        print("Illegal");
        print("Instruction");
    endif;
    
    if (cause == 2) then
        print("Illegal");
        print("Memory");
        print("Access");
    endif;
    
    if (cause == 3) then
        print("Arithmetic");
        print("exception");
    endif;
    
    if (cause == 4) then
        print("Illegal");
        print("operands");
    endif;
    
    print("-----");
    
    //Going to the Exit() Syscall.
    SP = SP + 1;
    physicalSP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512);
    [physicalSP - 1] = 10;
    inline "JMP 11776";	
    
endif;
