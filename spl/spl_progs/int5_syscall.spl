alias physicalSP S0;
alias sysCallNo S1;
alias currentPID S2;
alias currentPCB S3;
alias newPID S4;
alias newPCB S5;
alias i S6;
alias newPTBR S7;
alias j S8; 
alias childPSP S9;

// Calculating the Physical SP address
physicalSP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512);

// Extracting System Call Number
sysCallNo = [physicalSP - 1];

//Common to both methods irrespective of syscall no.
//Setting the PPOFT in the PCB
currentPID = (PTBR - 1024) / 8;

// Calculating PCB entry for currentPID
currentPCB = READY_LIST + 32 * currentPID;

//Fork Syscall
if (sysCallNo == 8) then
    //looking for a Free PCB
    newPID = (currentPID + 1) % 32; 
    
    while (newPID != currentPID) do
        newPCB = READY_LIST + 32 * newPID;
        if [newPCB + 1] == 0 then
            break;
        else 
            newPID = (newPID + 1) % 32;
        endif;
    endwhile;
    
    if (newPID == currentPID) then
        // If not free PCB present
        [physicalSP - 2] = -1;
        ireturn;
    endif;
    
    //Setting PID in the PCB
    [newPCB] = newPID;
    
    //Setting the Parent PID value on the PID
    [newPCB + 31] = currentPID;
    
    //Setting the newPTBR value
    newPTBR = PAGE_TABLE + 8 * newPID;
    
    //Looking for a free page for stack
    i = 25;

    while (i < 64) do
        //Invalidating Index to FAT Table
        if ([MEM_LIST + i] == 0) then
            break;
        endif;
        i = i + 1;
    endwhile;
    
    // If adiquate free pages are not available 
    // A victim page can be found to swap with tho
    if (i == 64) then
        [physicalSP - 2] = -1;
        ireturn;
    endif;
    
    //Setting Stack Page entry
    [MEM_LIST + i] = 1; 
    [newPTBR + 6] = i;
    
    //Copying Data from Parent to Child Stack
    j = 0;
    while (j < 512) do
        [[newPTBR + 6] * 512 + j] = [[PTBR + 6] * 512 + j];
        j = j + 1;
    endwhile;
    
    //Code Page Entry Duplication
    i = 0;
    while (i < 3) do
        j = PTBR + i * 2;
        //Copying the Entry
        [newPTBR + i * 2] = [j];
        [newPTBR + i * 2 + 1] = [j + 1];
        
        //Modifying the DFL and MFL for Pure Demand paging
        if ([j] != -1) then
            //If the page is Valid; in Memory
            if([j + 1] == "11" || [j + 1] == "01") then
                [MEM_LIST + [j]] = [MEM_LIST + [j]] + 1;
            else
                if ([j] > 447) then
                    //If page is placed in the Swap Area
                    [DISK_LIST + [j]] = [DISK_LIST + [j]] + 1;
                endif;
            endif;
        endif;
        
        i = i + 1;
    endwhile;
    
    //Commiting DFL changes 
    store (6, 20);
    
    //Setting PTBR, IP and SP
    [newPCB + 5] = newPTBR;
    [newPCB + 4] = [physicalSP - 0];
    [newPCB + 3] = SP - 1;
    
    //Setting other registers
    [newPCB + 2] = BP;
    [newPCB + 6] = PTLR;
    [newPCB +  7] = R0;
    [newPCB +  8] = R1;
    [newPCB +  9] = R2;
    [newPCB + 10] = R3;
    [newPCB + 11] = R4;
    [newPCB + 12] = R5;
    [newPCB + 13] = R6;
    [newPCB + 14] = R7;
    
    //Copying the PPOFT
    i = 0;
    
    while (i < 8) do
        [newPCB + 15 + i * 2] = [currentPCB + 15 + i * 2];
        [newPCB + 16 + i * 2] = [currentPCB + 16 + i * 2];
        
        //Incrementing the System Wide File Counter
        [FILE_TABLE + [newPCB + 15 + i * 2] * 2 + 1] = [FILE_TABLE + [newPCB + 15 + i * 2] * 2 + 1] + 1;
        
        i = i + 1;
    endwhile;
    
    //Setting Child to READY
    [newPCB + 1] = 1;
    
    //Calculating the Child SP address
    childPSP = ([newPTBR + 2 * ((SP - 1) / 512)] * 512) + ((SP - 1) % 512);
    
    //Returning on Success for Parent
    [physicalSP - 2] = newPID;
    
    //Setting Return Value for Child Process
    [childPSP - 1] = -2;
    
    //Returning the Parent Program
    ireturn;
endif;

// if the INT 3 was improperly called
[physicalSP - 2] = -1;
ireturn;
