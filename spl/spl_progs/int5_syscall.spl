alias physicalSP S0;
alias sysCallNo S1;
alias currentPID S2;
alias currentPCB S3;
alias newPID S4;
alias newPCB S5;
alias i S6;
alias newPTBR S7;
alias j S8; 
alias childPSP S9;
alias nextPID S10;
alias nextPTBR S11;
alias flag S12;
alias replacePage S13;

// Calculating the Physical SP address
physicalSP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512);

// Extracting System Call Number
sysCallNo = [physicalSP - 1];

//Common to both methods irrespective of syscall no.
//Setting the PPOFT in the PCB
currentPID = (PTBR - 1024) / 8;

// Calculating PCB entry for currentPID
currentPCB = READY_LIST + 32 * currentPID;

//Fork Syscall
if (sysCallNo == 8) then
    //looking for a Free PCB
    newPID = (currentPID + 1) % 32; 
    
    while (newPID != currentPID) do
        newPCB = READY_LIST + 32 * newPID;
        if [newPCB + 1] == 0 then
            break;
        else 
            newPID = (newPID + 1) % 32;
        endif;
    endwhile;
    
    if (newPID == currentPID) then
        // If not free PCB present
        print("No PCBs");
        [physicalSP - 2] = -1;
        ireturn;
    endif;
    
    //Setting PID in the PCB
    [newPCB] = newPID;
    
    //Setting the Parent PID value on the PID
    [newPCB + 31] = currentPID;
    
    //Setting the newPTBR value
    newPTBR = PAGE_TABLE + 8 * newPID;
    
    //Looking for a free page for stack
    i = 25;

    while (i < 64) do
        //Invalidating Index to FAT Table
        if ([MEM_LIST + i] == 0) then
            break;
        endif;
        i = i + 1;
    endwhile;
    
    //Checking if Second Chance is required
    if (i != 64) then
        //Setting Stack Page entry
        [MEM_LIST + i] = 1; 
        [newPTBR + 6] = i;
        [newPTBR + 7] = "01";
    else
        // If adiquate free pages are not available 
        // A victim page can be found to swap with tho
        //Using Second Change Replacement
        nextPID = (newPID + 1) % 32;
        flag = -1;
        while(1 == 1) do
            nextPTBR = PAGE_TABLE + 8 * nextPID;
            
            i = 0;
            // Running through the Page Table for Victim Page
            while(i < 3) do
                j = nextPTBR + i * 2;
                //Checking if page used
                if ([j] != -1)then
                    //Checking if second chanced and not shared 
                    if ([j + 1] == "01" && [MEM_LIST + [j]] == 1) then
                        flag = i;
                        break;
                    endif;
                    
                    //Setting the Second Chance state marker
                    if ([j + 1] == "11") then
                        [j + 1] = "01";
                    endif;
                endif;
                
                i = i + 1;
            endwhile;
            
            //If a victim page is found
            if(flag != -1) then
                break;
            endif;
            
            nextPID = (nextPID + 1) % 32;
        endwhile;
        
        
        //Sending Victim Page to the Swap Area
        i = 448;
        while (i < 512) do
            if ([DISK_LIST + i] == 0) then
                break;
            endif;
        
            i = i + 1;
        endwhile;
        
        //If no swap block is found
        if (i == 512) then
            print("No pages in SWAP");
            
            //Going to the Exit() Syscall.
            SP = SP + 1;
            physicalSP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512);
            [physicalSP - 1] = 10;
            inline "JMP 11776";	
        endif;
        
        //Storing victim page number
        replacePage = [nextPTBR + flag * 2];
        
        //Swapping out the block
        store(replacePage, i);
        [DISK_LIST + i] = 1;
        
        //Setting entry to SWAP index
        [nextPTBR + flag * 2] = i;
        
        //Setting the page to invalid
        [nextPTBR + flag * 2  + 1] = "00";
         
        //Setting the found page to the Stack
        [newPTBR + 6] = replacePage;
        [newPTBR + 7] = "01";
        
        breakpoint;
    endif;
    
    
    //Copying Data from Parent to Child Stack
    j = 0;
    while (j < 512) do
        [[newPTBR + 6] * 512 + j] = [[PTBR + 6] * 512 + j];
        j = j + 1;
    endwhile;
    
    //Code Page Entry Duplication
    i = 0;
    while (i < 3) do
        j = PTBR + i * 2;
        //Copying the Entry
        [newPTBR + i * 2] = [j];
        [newPTBR + i * 2 + 1] = [j + 1];
        
        //Modifying the DFL and MFL for Pure Demand paging
        if ([j] != -1) then
            //If the page is Valid; in Memory
            if([j + 1] == "11" || [j + 1] == "01") then
                [MEM_LIST + [j]] = [MEM_LIST + [j]] + 1;
            else
                if ([j] > 447) then
                    //If page is placed in the Swap Area
                    [DISK_LIST + [j]] = [DISK_LIST + [j]] + 1;
                endif;
            endif;
        endif;
        
        i = i + 1;
    endwhile;
    
    //Commiting DFL changes 
    store (6, 20);
    
    //Setting PTBR, IP and SP
    [newPCB + 5] = newPTBR;
    [newPCB + 4] = [physicalSP - 0];
    [newPCB + 3] = SP - 1;
    
    //Setting other registers
    [newPCB + 2] = BP;
    [newPCB + 6] = PTLR;
    [newPCB +  7] = R0;
    [newPCB +  8] = R1;
    [newPCB +  9] = R2;
    [newPCB + 10] = R3;
    [newPCB + 11] = R4;
    [newPCB + 12] = R5;
    [newPCB + 13] = R6;
    [newPCB + 14] = R7;
    
    //Copying the PPOFT
    i = 0;
    
    while (i < 8) do
        [newPCB + 15 + i * 2] = [currentPCB + 15 + i * 2];
        [newPCB + 16 + i * 2] = [currentPCB + 16 + i * 2];
        
        //Incrementing the System Wide File Counter
        if ([newPCB + 15 + i * 2] != -1) then
            [FILE_TABLE + [newPCB + 15 + i * 2] * 2 + 1] = [FILE_TABLE + [newPCB + 15 + i * 2] * 2 + 1] + 1;
        endif;
        i = i + 1;
    endwhile;
    
    //Setting Child to READY
    [newPCB + 1] = 1;
    
    //Calculating the Child SP address
    childPSP = ([newPTBR + 2 * ((SP - 1) / 512)] * 512) + ((SP - 1) % 512);
    
    //Returning on Success for Parent
    [physicalSP - 2] = newPID;
    
    //Setting Return Value for Child Process
    [childPSP - 1] = -2;
    
    //Returning the Parent Program
    ireturn;
endif;

// if the INT 3 was improperly called
[physicalSP - 2] = -1;
ireturn;
