//Alias Declaration
alias sysCallNo S0;
alias fileName S1;
alias i S2;
alias FAT_entry S3;
alias j S4;
alias basic_block S5;
alias code_page S6;
alias k S7;
alias noBlocks S8;
alias physicalSP S9;
alias currentPID S10;
alias currentPCB S11;
alias PPID S12;

//Calculating Physical SP value
physicalSP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512);

//Get current PID
currentPID = (PTBR - 1024) / 8;

//Current PCB value
currentPCB = READY_LIST + 32 * currentPID;

// Extracting System Call Number
sysCallNo = [physicalSP - 1];

//Exec Syscall
if (sysCallNo == 9) then
    fileName = [physicalSP - 3];
    
    //checking FAT for the filename
	i = 0;
	while (i < 64) do
        if ([FAT + 8 * i] == fileName) then
           //Condition met if filename is found in FAT
           break;
        endif;
        
        i = i + 1;
    endwhile;
    
    //if file is not exist
    if (i == 64) then
	    [physicalSP - 2] = -1;
	    ireturn;
    endif;
    
    //Saving the FAT entry
	FAT_entry = i;

	//Counting the number of used data blocks in the EXEC file
	basic_block =  [FAT + 8 * FAT_entry + 2];
	load (1, basic_block);	
	j = 0;
	i = 0;
	
	//Since blocks are continuous.                                                        
	while (j < 256) do
	    if ([SCRATCHPAD + j] != -1) then
	        i = i + 1;
	    else
	        break;
	    endif;
	    j = j + 1;
	endwhile;
	 
	//Programs can only have 3 code blocks in XOS
	if (i > 3) then
	    [physicalSP - 2] = -1; 
        ireturn;
	endif;
	
	//Storing the number of blocks in EXEC file
	noBlocks = i;
	
	//Setting Code Page MFL and DFL structures
    i = 0;
    while (i < 3) do
        j = PTBR + i * 2;
        //Modifying the DFL and MFL for Pure Demand paging
        if ([j] != -1) then
            //If the page is Valid; in Memory
            if([j + 1] == "11" || [j + 1] == "01") then
                [MEM_LIST + [j]] = [MEM_LIST + [j]] - 1;
            else
                //If the page is in Swap, Decrementing its use
                if ([j] > 447) then
                    [DISK_LIST + [j]] = [DISK_LIST + [j]] - 1;
                endif;
            endif;
        endif;
        
        i = i + 1;
    endwhile;
    
    //Commiting DFL changes 
    store(6, 20);
    
    //Setting the PPPT for the new Program
    i = 0;
    while (i < 3) do
        code_page = PTBR + 2 * i;
              
        if (i < noBlocks) then
            [code_page] = [SCRATCHPAD + i];
        else
            [code_page] = -1;
        endif;
        [code_page + 1] = "00";
                
        i = i + 1;
    endwhile;
    
    //Stack Page Auxillary Setting 
    [PTBR + 7] = "01";
    
    //Closing all files
    i = 0;
    while (i < 8) do
        j = currentPCB + 15 + i * 2;
        if([j] != -1) then
            //Reducing System Wide file Table Count
            [FILE_TABLE + j * 2 + 1] = [FILE_TABLE + j * 2 + 1] - 1;
            
            //Invalidating entry if not in use
            if ([FILE_TABLE + j * 2 + 1] == 0) then
	            [FILE_TABLE + j * 2] = -1;
	        endif;
	        
	        //Invalidating the PPOFT entry
	        [j] = -1;
	        [j + 1] = -1;
        endif;
        i = i + 1;
    endwhile;
    
    //Setting Logical SP to start of page 3
    SP = 3 * 512;
    
    //Updating SP Value
    physicalSP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512);
    
    //Setting IP value to 0
    [physicalSP] = 0;
    
    // returning to the loaded program
    ireturn;
endif;

//Getpid Syscall
if (sysCallNo == 11) then
    //Setting Return Value to the PID
    [physicalSP - 2] = currentPID;
    
    // returning to the loaded program
    ireturn;
endif;

//Getppid Syscall
if (sysCallNo == 12) then
    //Getting out the PPID
    PPID = [currentPCB + 31];
    
    //Setting Return Value to the PID
    [physicalSP - 2] = PPID;
    
    // returning to the loaded program
    ireturn;
endif;

// if the INT 6 was improperly called
[physicalSP - 2] = -1;                            
ireturn;
