//Alias Declaration
alias sysCallNo S0;
alias fileName S1;
alias i S2;
alias FAT_entry S3;
alias j S4;
alias basic_block S5;
alias code_page S6;
alias k S7;
alias noBlocks S8;

// Extracting System Call Number
sysCallNo = [physicalSP - 1];


//Exec Syscall
if (sysCallNo == 9) then
    fileName = [physicalSP - 3];
    
    //checking FAT for the filename
	i = 0;
	while (i < 64) do
        if ([FAT + 8 * i] == fileName) then
           //Condition met if filename is found in FAT
           break;
        endif;
        
        i = i + 1;
    endwhile;
    
    //if file is not exist
    if (i == 64) then
	    [physicalSP - 2] = -1;
	    ireturn;
    endif;
    
    //Saving the FAT entry
	FAT_entry = i;
	
	//Counting the number of used data blocks in the EXEC file
	basic_block =  [FAT + 8 * FAT_entry + 2];
	load (1, basic_block);	
	j = 0;
	i = 0;
	
	while (j < 256) do
	    if ([SCRATCHPAD + j] != -1) then
	        i = i + 1;
	        //Break on -1?
	    endif;
	    j = j + 1;
	endwhile;
	
	//Programs can only have 3 code blocks in XOS
	if (i > 3) then
	    [physicalSP - 2] = -1;
    ireturn;
	endif;
	
	//Storing the number of blocks in EXEC file
	noBlocks = j;
	
	//Checking if Adequate Page Blocks used in current process
    j = 0;
    
    //Removing one for stack
    while (j < 3) do
        if ([PTBR + j * 2] != -1) then
            i = i - 1;
        endif;
        j = j + 1;
    endwhile;
    
    //checking lesser blocks are going to be used.
    if (i > 0) then
        //since we're only deleting the excess code blocks and useing Stack.
        j = 3;
        while (i > 0) do
            code_page = PTBR + 2 * j;
            if ([code_page] != -1) then
            
                //Clearing MFL entry
                [MEM_LIST + [code_page]] = 0;
                
                //Clearing Page Table entry
                [code_page] = -1;
                [code_page + 1] = "00";
                
                i = i - 1;
            endif;
            
            j = j - 1;
        endwhile;
    endif;
    
    //Checking if page allocation is required
    if (i < 0) then
        //Since User Pages start at 25
        k = 0;
        j = 25; 
        while (i > 0) do
        
            while (j < 448) do
                if ([DISK_LIST + j] == 0) then
                    break;
                endif;
        
                j = j + 1;
            endwhile;
 
            //if no free file is found
            if (j == 448) then 
                [physicalSP - 2] = -1;
                ireturn;
            endif;
            
            [DISK_LIST + j] = 1;
            
            //Adding this page to the process table
            while (k < 4) do
                code_page = PTBR + 2 * k;
                if ([code_page] != -1) then
                    [code_page] = j;
                    [code_page] = "01";
                    break;
                endif;
                k = k + 1;
            end;
            
            //This error should not take place, since pages are counted.
            if (k == 4) then
                print("No more Pages");
                [physicalSP - 2] = -1;
                ireturn;
            endif;
            
            i = i + 1;       
        endwhile;
    endif;
    
    //Loading Code Blocks to the Process Table
    load (1, basic_block);
    i = 0;
    while (i < noBlocks) do
        //Loading Code Blocks into the pages
        load([PTBR + 2 * i], [SCRATCHPAD + i]);
        
        i = i + 1;
    endwhile;
    
    //!!!!!!!!!!!!!!!Closing all files
    
    //Setting Logical SP to start of page 3
    SP = 3 * 512;
    
    //Calculating new physical SP value and setting IP
    
endif;

// if the INT 6 was improperly called
[physicalSP - 2] = -1;
ireturn;
