//Alias Declaration
alias sysCallNo S0;
alias fileName S1;
alias i S2;
alias FAT_entry S3;
alias j S4;
alias basic_block S5;
alias code_page S6;
alias k S7;
alias noBlocks S8;
alias physicalSP S9;
alias currentPID S10;
alias currentPCB S11;

//Calculating Physical SP value
physicalSP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512);

//Get current PID
currentPID = (PTBR - 1024) / 8;

//Current PCB value
currentPCB = READY_LIST + 32 * currentPID;

// Extracting System Call Number
sysCallNo = [physicalSP - 1];

//Exec Syscall
if (sysCallNo == 9) then
    fileName = [physicalSP - 3];
    
    //checking FAT for the filename
	i = 0;
	while (i < 64) do
        if ([FAT + 8 * i] == fileName) then
           //Condition met if filename is found in FAT
           break;
        endif;
        
        i = i + 1;
    endwhile;
    
    //if file is not exist
    if (i == 64) then
	    [physicalSP - 2] = -1;
	    ireturn;
    endif;
    
    //Saving the FAT entry
	FAT_entry = i;
	
	//Counting the number of used data blocks in the EXEC file
	basic_block =  [FAT + 8 * FAT_entry + 2];
	load (1, basic_block);	
	j = 0;
	i = 0;
	
	//Since blocks are continuous.                                                        
	while (j < 256) do
	    if ([SCRATCHPAD + j] != -1) then
	        i = i + 1;
	    else
	        break;
	    endif;
	    j = j + 1;
	endwhile;
	 
	//Programs can only have 3 code blocks in XOS
	if (i > 3) then
	    [physicalSP - 2] = -1; 
        ireturn;
	endif;
	
	//Storing the number of blocks in EXEC file
	noBlocks = i;
	
	//Checking if Adequate Page Blocks used in current process
    j = 0;
    
    //4th page dedicated for stack
    while (j < 3) do
        if ([PTBR + j * 2] != -1) then
            i = i - 1;
        endif;
        j = j + 1;
    endwhile;
    
    //checking lesser blocks are going to be used.
    if (i < 0) then
        //since we're only deleting the excess code blocks and using Stack.
        j = 2;
        while (i < 0) do
            code_page = PTBR + 2 * j;
            if ([code_page] != -1) then
            
                //Clearing MFL entry
                [MEM_LIST + [code_page]] = 0;
                
                //Clearing Page Table entry
                [code_page] = -1;
                [code_page + 1] = "00";
                
                i = i + 1;
            endif;
            j = j - 1;
        endwhile;
    endif;
    
    //Checking if page allocation is required
    if (i > 0) then
        //Since User Pages start at 25
        k = 0;
        j = 25; 
        while (i > 0) do
            while (j < 64) do
                if ([MEM_LIST + j] == 0) then
                    break;
                endif;
        
                j = j + 1;
            endwhile;
 
            //if no free page is found
            if (j == 64) then 
                [physicalSP - 2] = -1;     
                ireturn;
            endif;
            
            [MEM_LIST + j] = 1;
            
            //Adding this page to the process table
            while (k < 3) do
                code_page = PTBR + 2 * k;
                
                if ([code_page] == -1) then
                    [code_page] = j;
                    [code_page + 1] = "01";
                    break;
                endif;
                k = k + 1;
            endwhile;
            
            //This error should not take place, since pages are counted.
            if (k == 3) then
                print("No more Pages");
                [physicalSP - 2] = -1;   
                ireturn;
            endif;
            
            i = i - 1;       
        endwhile;
    endif;
    
    //Loading Code Blocks to the Process Table pages
    load (1, basic_block);
    i = 0;
   
    while (i < noBlocks) do
        //Loading Code Blocks into the pages
        load([PTBR + 2 * i], [SCRATCHPAD + i]);
        
        i = i + 1;
    endwhile;
    
    //Closing all files
    i = 0;
    while (i < 8) do
        j = currentPCB + 15 + i * 2;
        if([j] != -1) then
            //Reducing System Wide file Table Count
            [FILE_TABLE + j * 2 + 1] = [FILE_TABLE + j * 2 + 1] - 1;
            
            //Invalidating entry if not in use
            if ([FILE_TABLE + j * 2 + 1] == 0) then
	            [FILE_TABLE + j * 2] = -1;
	        endif;
	        
	        //Invalidating the PPOFT entry
	        [j] = -1;
	        [j + 1] = -1;
        endif;
        i = i + 1;
    endwhile;
    
    //Setting Logical SP to start of page 3
    SP = 3 * 512;
    
    //Updating SP Value
    physicalSP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512);
    
    //Setting IP value to 0
    [physicalSP] = 0;
    
    // returning to the loaded program
    ireturn;
endif;

// if the INT 6 was improperly called
[physicalSP - 2] = -1;                            
ireturn;
